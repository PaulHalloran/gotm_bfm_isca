!$Id: $
#include"cppdefs.h"
!-----------------------------------------------------------------------
!BOP
!
! !MODULE: bio_bfm --- BFM bio model \label{sec:bio_bfm}
!
! !INTERFACE:
   module bio_bfm
!
! !DESCRIPTION:
!
!
! !USES:
!  default: all is private.
   use bio_var
   private
!
! !PUBLIC MEMBER FUNCTIONS:
   public init_bio_bfm, pointers_gotm_bfm,            &
          var_info_bfm, envforcing_bfm, do_bio_bfm,   &
          allocate_memory_bfm,reset_diagonal,         &
          test_on_negative_states, end_bio_bfm,       &
          do_bfm_river_loads,assign_adv_rates,        &
          CalcVertFluxAtLev
!
!
! !PRIVATE DATA MEMBERS:
   REALTYPE,dimension(:),allocatable :: cdepth,wx
!
! !REVISION HISTORY:
!  Original author(s): Marcello Vichi
!  from a template by Hans Burchard & Karsten Bolding
!
!  $Log: $
!EOP
!-----------------------------------------------------------------------

   contains

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Initialise the template bio module
!
! !INTERFACE:
   subroutine init_bio_bfm(nlev,out_unit)
!
! !DESCRIPTION:
!  Here, the main communication of array dimensions between GOTM
!  and BFM is done.
!
!
! !USES:
   use mem, only: NO_D3_BOX_STATES, NO_BOXES,          &
                  NO_BOXES_X, NO_BOXES_Y, NO_BOXES_Z,  &
                  NO_D2_BOX_STATES, NO_BOXES_XY,       &
                  NO_D2_BOX_DIAGNOSS, NO_D3_BOX_DIAGNOSS,&
                  NO_D2_BOX_FLUX, NO_D3_BOX_FLUX,&
                  NO_STATES

   IMPLICIT NONE
!
! !INPUT PARAMETERS:
   integer,          intent(in)   :: nlev
   integer,          intent(in)   :: out_unit
!
   integer :: i,rc
! !REVISION HISTORY:
!  Original author(s): Marcello Vichi
!  from a template by Hans Burchard & Karsten Bolding
!!
!EOP
!-----------------------------------------------------------------------
!BOC
   LEVEL2 'init_bio_bfm'


   ! BFM  --> GOTM
   numc  = NO_D3_BOX_STATES
   numbc = NO_D2_BOX_STATES
   numc_diag  = NO_D3_BOX_DIAGNOSS
   numbc_diag = NO_D2_BOX_DIAGNOSS
   numc_flux  = NO_D3_BOX_FLUX
   numbc_flux = NO_D2_BOX_FLUX
   ! numcc is the number of transported variables
   numcc = numc

   ! GOTM --> BFM
   NO_BOXES_X  = 1
   NO_BOXES_Y  = 1
   NO_BOXES_Z  = nlev
   NO_BOXES    = NO_BOXES_X * NO_BOXES_Y * NO_BOXES_Z
   NO_BOXES_XY = NO_BOXES_X * NO_BOXES_Y
   NO_STATES   = NO_D3_BOX_STATES * NO_BOXES +   &
                 NO_D2_BOX_STATES * NO_BOXES_XY
   !LOGUNIT = out_unit

   LEVEL3 'pelagic variables =',numc
   LEVEL3 'pelagic transported variables =',numcc
   LEVEL3 'benthic variables =',numbc
   LEVEL3 'pelagic variables prepared for output',numc_diag
   LEVEL3 'benthic variables prepared for output',numbc_diag
   LEVEL3 'NO_BOXES_X=',NO_BOXES_X
   LEVEL3 'NO_BOXES_Y=',NO_BOXES_Y
   LEVEL3 'NO_BOXES_Z=',NO_BOXES_Z
   LEVEL3 'NO_BOXES=',NO_BOXES
   LEVEL3 'NO_BOXES_XY=',NO_BOXES_XY
   LEVEL3 'NO_STATES=',NO_STATES
   LEVEL3 'Step 1 of GOTM <-> BFM initialisation done ...'

!  sfl=_ZERO_
!  sfl_read=_ZERO_
   allocate(cdepth(1:NO_BOXES),stat=rc)
   allocate(wx(1:NO_BOXES),stat=rc)
   return

   end subroutine init_bio_bfm
!EOC
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!BOP
!
! !ROUTINE: Initialize BFM and GETM shared memory
!
! !INTERFACE:
   subroutine pointers_gotm_bfm()
!
! !DESCRIPTION:
! Allocate pointers to GOTM memory
!
! !USES:
   use mem, only: D3STATE,D3SOURCE,D3SINK,D3STATETYPE, &
                  D3DIAGNOS,D2STATE,D2SOURCE,D2SINK,   &
                  D2STATETYPE,NO_BOXES,NO_BOXES_XY,    &
                  D2DIAGNOS,NO_D2_BOX_STATES,          &
                  NO_D2_BOX_DIAGNOSS

   IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! !REVISION HISTORY:
!  Original author(s): Marcello Vichi
!
! !LOCAL VARIABLES:

   !---------------------------------------------
   ! Pelagic pointers
   !---------------------------------------------
   D3STATE  => cc(:,1:NO_BOXES)
   D3SOURCE => pp(:,:,1:NO_BOXES)
   D3SINK   => dd(:,:,1:NO_BOXES)
   D3STATETYPE => pelvar_type
   if (numc_diag > 0) D3DIAGNOS => diag(:,1:NO_BOXES)

   !---------------------------------------------
   ! Benthic pointers
   !---------------------------------------------
   if (bio_setup >=2 ) then
      D2STATE  => ccb(:,1:NO_BOXES_XY)
      D2SOURCE => ppb(:,:,1:NO_BOXES_XY)
      D2SINK   => ddb(:,:,1:NO_BOXES_XY)
      D2STATETYPE => benvar_type
      if (numbc_diag>0) D2DIAGNOS => diagb(:,1:NO_BOXES_XY)
   else
      ! allocate memory anyhow to avoid problems with BFM allocation
      allocate(D2STATE(1:NO_D2_BOX_STATES,1:NO_BOXES_XY))
      allocate(D2SOURCE(1:NO_D2_BOX_STATES,1:NO_D2_BOX_STATES,1:NO_BOXES_XY))
      allocate(D2SINK(1:NO_D2_BOX_STATES,1:NO_D2_BOX_STATES,1:NO_BOXES_XY))
      allocate(D2STATETYPE(1:NO_D2_BOX_STATES ))
      if (numbc_diag>0)  &
         allocate(D2DIAGNOS(1:NO_D2_BOX_DIAGNOSS,1:NO_BOXES_XY))
   end if

   end subroutine pointers_gotm_bfm
!EOC
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Providing info on variables
!
! !INTERFACE:
   subroutine var_info_bfm()
!
! !DESCRIPTION:
!  This subroutine provides information on the variables. To be used
!  when storing data in NetCDF files.
!
! !USES:
   use mem
   IMPLICIT NONE
!
! !REVISION HISTORY:
!  Original author(s): Marcello Vichi
!  from a template by Hans Burchard & Karsten Bolding
!
!EOP
!-----------------------------------------------------------------------
!BOC
   call set_var_info_bfm
   return
   end subroutine var_info_bfm
!EOC

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Light and other environmental forcing used in the BFM
!
! !INTERFACE
   subroutine envforcing_bfm(nlev,h,t,s,rho,I_0,uwind_gotm,vwind_gotm, &
                             u_taub,bioshade_feedback,bioshade,abioshade)
!
! !DESCRIPTION
!
! !USES
! BFM modules
use constants, ONLY: E2W
use mem_Param, ONLY: p_eps0, p_epsESS, p_PAR,p_small
use mem,       ONLY: NO_BOXES, R6c, PhytoPlankton, xEPS, ESS, ERHO, &
                     iiPhytoPlankton, iiL, Chla, ETW, ESW, Wind,R9x,    &
                     EUWIND,EVWIND,ETAUB,Depth, EIR, ABIO_eps,p_eps0
use mem_Param,  ONLY: p_eps0, p_epsESS,p_poro
use global_interface,   ONLY: eTq


IMPLICIT NONE
!
! !INPUT PARAMETERS:
   integer                              :: nlev
   REALTYPE, intent(in)                 :: h(0:nlev)
   REALTYPE, intent(in)                 :: t(0:nlev)
   REALTYPE, intent(in)                 :: rho(0:nlev)
   REALTYPE, intent(in)                 :: s(0:nlev)
   REALTYPE, intent(in)                 :: I_0
   REALTYPE, intent(in)                 :: uwind_gotm,vwind_gotm,u_taub
   logical, intent(in)                  :: bioshade_feedback
   REALTYPE, intent(in),optional        :: abioshade(0:nlev)
!
! !OUTPUT PARAMETERS:
   REALTYPE, intent(out)                :: bioshade(0:nlev)!
! !REVISION HISTORY:
!  Original author(s): Marcello Vichi
!  from a template by Hans Burchard & Karsten Bolding
!
! !LOCAL VARIABLES:
   integer             :: i,n
   REALTYPE            :: psilt
!EOP
!-----------------------------------------------------------------------
!BOC

!   LEVEL2 'calculating environmental forcings for the BFM'

   !---------------------------------------------
   ! Assign depths of layers
   ! temperature and salinity
   !---------------------------------------------
   Depth(:) = h(1:nlev)
    cdepth(NO_BOXES) =depth(NO_BOXES)
    EUWIND(1)=uwind_gotm
    EVWIND(1)=vwind_gotm
    Wind= sqrt( EUWIND(1) * EUWIND(1) + EVWIND(1) *EVWIND(1))
    ETAUB(1)=u_taub
    do n=NO_BOXES-1,1,-1
       cdepth(n)=depth(n)+ cdepth(n+1)
    enddo
   ETW(:) = t(1:nlev)
   ESW(:) = s(1:nlev)
   ERHO(:) = rho(1:nlev)
   psilt=(p_poro(1) - 0.38662 )/ 0.00415
!  ESS(:) = 10000.0 * min(1.0,20.0/cdepth(1))* max(0.5,psilt)/7.0 
!  ESS(:) = 10000.0 * min(1.0,10.0/cdepth(1))* max(0.5,psilt)/7.0 &
!                     /eTq(  ETW(nlev), 2.0D+00) 
   ESS(:)=R9x(:)
   p_eps0=1.17692307692-0.0307692307692*ESW(1)


            
   !---------------------------------------------
   ! Compute extinction coefficient
   !---------------------------------------------

   if (p_eps0 ==0.0 ) then
     ABIO_eps(:) = abioshade(1:nlev)
   end if

   call  CalcVerticalExtinction( )

   !---------------------------------------------
   ! Notice that irradiance in the BFM is in
   ! uE/m2/s and is defined at the top of each
   ! layer (the derivation of the middle-layer
   ! EIR for production is done in the
   ! Phytoplankton routines)
   !---------------------------------------------
   EIR(nlev) = max(p_small,p_PAR*I_0/E2W)
   do i=nlev,2,-1
     EIR(i-1) = EIR(i)*exp(-xEPS(i)*Depth(i))
   end do

   !---------------------------------------------
   ! bioshade is instead derived in the
   ! middle of the layer and it's non-dimensional
   !---------------------------------------------
   if (bioshade_feedback) &
     bioshade(1:nlev) =  EIR(:)*exp(-xEPS(:)*Depth(:)*0.5)/ EIR(nlev)

   end subroutine envforcing_bfm
!EOC
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Right hand sides of the BFM model
!
! !INTERFACE
   subroutine do_bio_bfm(first)
!
! !DESCRIPTION
!  This subroutine is a wrapper for the computing core of the BFM
!
! !USES
   use mem_param, only: AssignAirPelFluxesInBFMFlag,AssignPelBenFluxesInBFMFlag
   use mem, only: sediPI, sediR6, sediR2,iiC,iiN,iiP,iiS,iiL, &
                  ppR2c, ppR6c, ppR6n, ppR6p, ppR6s, NO_BOXES_Z,   &
                  ppR1c, ppR1n, ppR1p,   &
                  ppO2o,ppN1p,ppN3n,ppN4n,ppN5s,ppN6r,  &
                  NO_D3_BOX_STATES, Depth,              &
                  ppPhytoPlankton,iiPhytoPlankton, &
                  PELBOTTOM, PELSURFACE, &
                  jK3G4n,jK13K3n
   use constants,  only: SEC_PER_DAY
   use gotm_error_msg, only:gotm_error

   IMPLICIT NONE
!
   logical,intent(in)          :: first


   logical                     :: ll_larger
   integer                     :: n,k,i,j,l
   REALTYPE                    :: topm3psec,corr,Nloss
!See "USE association" above
!
! !REVISION HISTORY:
!  Original author(s): Marcello Vichi
!  from template by Hans Burchard, Karsten Bolding
!
! !LOCAL VARIABLES:
!EOP
!-----------------------------------------------------------------------
!BOC

   !---------------------------------------------
   ! Compute BFM terms
   !---------------------------------------------
   call SiltDynamics
   call EcologyDynamics

   Nloss=jK3G4n(1)-jK13K3n(1);
   !---------------------------------------------
   ! Surface fluxes
   !---------------------------------------------
   if ( bio_setup ==2 ) return
   topm3psec=_ONE_/Depth(NO_BOXES_Z)/ SEC_PER_DAY
   if ( .NOT. AssignAirPelFluxesInBFMFlag ) then
     sfl(ppO2o) =   PELSURFACE(ppO2o,1) *topm3psec
   endif
   select case (surface_flux_method)
        case (-1)! absolutely nothing
        case (0) ! constant
           sfl(ppN3n) =   0.12  *topm3psec
           sfl(ppN4n) =   0.09  *topm3psec
           sfl(ppN1p) =   0.0  !0.0
        case (1) ! from file via sfl_read
           ! fluxes are in mmol m-2 d-1
           sfl(ppN3n) =    sfl_N3n  *topm3psec
           sfl(ppN4n) =    sfl_N4n  *topm3psec
        case (3) ! sfl array filled externally - for 3D models
           sfl(ppN3n)= Nloss *0.12/0.21 * topm3psec
           sfl(ppN3n)= Nloss *0.09/0.21 * topm3psec
        case default
   end select

   !---------------------------------------------
   ! Bottom fluxes
   !---------------------------------------------
   topm3psec=1.0/Depth(1)/ SEC_PER_DAY
   if ((bio_setup == 3 ) .and. ( .NOT.AssignPelBenFluxesInBFMFlag)) then

      bfl(ppR6c) = PELBOTTOM(ppR6c,1)*topm3psec
      bfl(ppR6n) = PELBOTTOM(ppR6n,1)*topm3psec
      bfl(ppR6p) = PELBOTTOM(ppR6p,1)*topm3psec
      bfl(ppR6s) = PELBOTTOM(ppR6s,1)*topm3psec

      bfl(ppR1c) =  PELBOTTOM(ppR1c,1)*topm3psec
      bfl(ppR1n) =  PELBOTTOM(ppR1n,1)*topm3psec
      bfl(ppR1p) =  PELBOTTOM(ppR1p,1)*topm3psec

      bfl(ppO2o) = PELBOTTOM(ppO2o,1)*topm3psec
      bfl(ppN1p) = PELBOTTOM(ppN1p,1)*topm3psec
      bfl(ppN3n) = PELBOTTOM(ppN3n,1)*topm3psec
      bfl(ppN4n) = PELBOTTOM(ppN4n,1)*topm3psec
      bfl(ppN5s) = PELBOTTOM(ppN5s,1)*topm3psec
      bfl(ppN6r) = PELBOTTOM(ppN6r,1)*topm3psec

      do i=1,iiPhytoPlankton
        k=ppPhytoPlankton(i,iiC) 
        bfl(k) = PELBOTTOM(k,1)*topm3psec
        k=ppPhytoPlankton(i,iiN) 
        bfl(k) = PELBOTTOM(k,1)*topm3psec
        k=ppPhytoPlankton(i,iiP) 
        bfl(k) = PELBOTTOM(k,1)*topm3psec
        k=ppPhytoPlankton(i,iiL) 
        bfl(k) = PELBOTTOM(k,1)*topm3psec
        k=ppPhytoPlankton(i,iiS)
        if ( k > 0 ) bfl(k) = PELBOTTOM(k,1)*topm3psec
      enddo
   endif
   end subroutine do_bio_bfm
!EOC
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE:  Assign  adv_rates
!
! !INTERFACE
   subroutine CalcVertFluxAtLev(statenr,lev,out)
!
! !DESCRIPTION
! !USES
   IMPLICIT NONE
!
   integer,intent(IN)          :: statenr
   integer,intent(IN)          :: lev
   REALTYPE,intent(OUT)        :: out

   out=nuhpm(lev)*(cc(statenr,lev+1)-cc(statenr,lev))-ws(statenr,lev)* &
                     (cc(statenr,lev+1)+cc(statenr,lev))* 0.5
   if (ws(statenr,lev).ne.0.0) write(93,*) ws(statenr,lev)
   return
   end subroutine CalcVertFluxAtLev
!EOC
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE:  Assign  adv_rates
!
! !INTERFACE
   subroutine assign_adv_rates(dt)
!
! !DESCRIPTION
!  This subroutine is a wrapper for the computing core of the BFM
!
! !USES
   use mem, only: sediPI, sediR6, sediR2,iiC,iiN,iiP,iiS,iiL, &
                  sediMeZ,sediMiZ, &
                  ppR2c, ppR6c, ppR6n, ppR6p, ppR6s, NO_BOXES_Z,   &
                  ppR1c, ppR1n, ppR1p,   &
                  NO_D3_BOX_STATES, Depth,              &
                  ppPhytoPlankton,iiPhytoPlankton, &
                  ppMesoZooPlankton,iiMesoZooPlankton, &
                  ppMicroZooPlankton,iiMicroZooPlankton, &
                  PELBOTTOM, PELSURFACE
   use constants,  only: SEC_PER_DAY
   use gotm_error_msg, only:gotm_error

   IMPLICIT NONE
!
   REALTYPE,intent(in)          :: dt

   logical                     :: ll_larger
   integer                     :: n,k,i,j,l
   REALTYPE                    :: topm3psec,corr2
   REALTYPE                    :: corr(NO_BOXES_Z)        

   !---------------------------------------------
   ! Transfer sinking velocities (m/d -> m/s)
   !---------------------------------------------
   if ( bio_setup ==2 ) return
   do i=1,iiPhytoPlankton
     ll_larger=(maxval(sediPI(i,1:NO_BOXES_Z))> 0.0)
     l=ppPhytoPlankton(i,iiC)
     c1dimz(NO_BOXES_Z)=0.0;
     c1dimz(1:NO_BOXES_Z-1)=(Depth(2:NO_BOXES_Z)*sediPI(i,1:NO_BOXES_Z-1) &
                            +Depth(1:NO_BOXES_Z-1)*sediPI(i,2:NO_BOXES_Z))/ &
                                (Depth(1:NO_BOXES_Z)+Depth(2:NO_BOXES_Z-1))
     corr=min(cdepth(1)*rel_max_sedi_rate,abs(c1dimz))/(1.0D-80+abs(c1dimz))


     ws(l,1:NO_BOXES_Z) = -c1dimz(1:NO_BOXES_Z)/SEC_PER_DAY*corr
     llws(l)=ll_larger
     ws(l,0)= ws(l,1)

     k=ppPhytoPlankton(i,iiN)
     ws(k,0:NO_BOXES_Z) =ws(l,0:NO_BOXES_Z)
     llws(k)=ll_larger
     k=ppPhytoPlankton(i,iiP)
     ws(k,0:NO_BOXES_Z) = ws(l,0:NO_BOXES_Z)
     llws(k)=ll_larger
     k=ppPhytoPlankton(i,iiL)
     ws(k,0:NO_BOXES_Z) = ws(l,0:NO_BOXES_Z)
     llws(k)=ll_larger
     k=ppPhytoPlankton(i,iiS)
     if ( i==1  ) then 
          ws(k,0:NO_BOXES_Z) = ws(l,0:NO_BOXES_Z)
          llws(k)=ll_larger
     endif
   enddo
   do i=1,iiMesoZooPlankton
     ll_larger=(maxval(abs(sediMeZ(i,1:NO_BOXES_Z)))> 0.001)
     l=ppMesoZooPlankton(i,iiC)
     c1dimz(NO_BOXES_Z)=0.0;
     c1dimz(1:NO_BOXES_Z-1)=(Depth(2:NO_BOXES_Z)*sediMeZ(i,1:NO_BOXES_Z-1) &
                            +Depth(1:NO_BOXES_Z-1)*sediMeZ(i,2:NO_BOXES_Z))/ &
                                (Depth(1:NO_BOXES_Z)+Depth(2:NO_BOXES_Z-1))

     corr=min(cdepth(1)*rel_max_sedi_rate,abs(c1dimz))/(1.0D-80+abs(c1dimz))

     ws(l,1:NO_BOXES_Z) = -c1dimz(1:NO_BOXES_Z)/SEC_PER_DAY*corr
     llws(l)=ll_larger
     ws(l,0)= ws(l,1)

     k=ppMesoZooPlankton(i,iiN)
     if ( k>0 ) then
       ws(k,0:NO_BOXES_Z) =ws(l,0:NO_BOXES_Z)
       llws(k)=ll_larger
       k=ppMesoZooPlankton(i,iiP)
       ws(k,0:NO_BOXES_Z) = ws(l,0:NO_BOXES_Z)
       llws(k)=ll_larger
     endif
   enddo
   do i=1,iiMicroZooPlankton
     ll_larger=(maxval(abs(sediMiZ(i,1:NO_BOXES_Z)))> 0.001)
     l=ppMesoZooPlankton(i,iiC)
     c1dimz(NO_BOXES_Z)=0.0;
     c1dimz(1:NO_BOXES_Z-1)=(Depth(2:NO_BOXES_Z)*sediMiZ(i,1:NO_BOXES_Z-1) &
                            +Depth(1:NO_BOXES_Z-1)*sediMiZ(i,2:NO_BOXES_Z))/ &
                                (Depth(1:NO_BOXES_Z)+Depth(2:NO_BOXES_Z-1))
     corr=min(cdepth(1)*rel_max_sedi_rate,abs(c1dimz))/(1.0D-80+abs(c1dimz))


     ws(l,1:NO_BOXES_Z) = -c1dimz(1:NO_BOXES_Z)/SEC_PER_DAY*corr
     llws(l)=ll_larger
     ws(l,0)= ws(l,1)

     k=ppMicroZooPlankton(i,iiN)
     if ( k>0 ) then
       ws(k,0:NO_BOXES_Z) =ws(l,0:NO_BOXES_Z)
       llws(k)=ll_larger
       k=ppMesoZooPlankton(i,iiP)
       ws(k,0:NO_BOXES_Z) = ws(l,0:NO_BOXES_Z)
       llws(k)=ll_larger
     endif
   enddo

   c1dimz(NO_BOXES_Z)=0.0;
   c1dimz(1:NO_BOXES_Z-1)=(Depth(2:NO_BOXES_Z)*sediR2(1:NO_BOXES_Z-1) &
                            +Depth(1:NO_BOXES_Z-1)*sediR2(2:NO_BOXES_Z))/ &
                                (Depth(1:NO_BOXES_Z)+Depth(2:NO_BOXES_Z-1))
   corr=min(cdepth(1)*rel_max_sedi_rate,abs(c1dimz))/(1.0D-80+abs(c1dimz))
   ws(ppR2c,1:NO_BOXES_Z) = -c1dimz/SEC_PER_DAY*corr
   ws(ppR2c,0) = ws(ppR2c,1)
   llws(ppR2c)=.TRUE.

   ws(ppR6c,NO_BOXES_Z)=0.0
   corr=min(cdepth(1)*rel_max_sedi_rate,abs(sediR6))/(1.0D-80+abs(sediR6))
   c1dimz(1:NO_BOXES_Z-1)=(Depth(2:NO_BOXES_Z)*sediR6(1:NO_BOXES_Z-1) &
                            +Depth(1:NO_BOXES_Z-1)*sediR6(2:NO_BOXES_Z))/ &
                                (Depth(1:NO_BOXES_Z)+Depth(2:NO_BOXES_Z-1))
   ws(ppR6c,1:NO_BOXES_Z) = -c1dimz/SEC_PER_DAY*corr
   ws(ppR6c,0) = ws(ppR6c,1)

   ws(ppR6n,0:NO_BOXES_Z) =ws(ppR6c,0:NO_BOXES_Z)
   ws(ppR6p,0:NO_BOXES_Z) =ws(ppR6c,0:NO_BOXES_Z)
   ws(ppR6s,0:NO_BOXES_Z) =ws(ppR6c,0:NO_BOXES_Z)

   llws(ppR6c)=.TRUE.
   llws(ppR6n)=.TRUE.
   llws(ppR6p)=.TRUE.
   llws(ppR6s)=.TRUE.

   return

   end subroutine assign_adv_rates
!EOC
!-------------------------------------------------------------------------
!BOP
!
! !IROUTINE: To get info on riverloads amd move values to array and make avialble for output
!
! !INTERFACE
   subroutine do_bfm_river_loads(action ,n,var)
!
! !DESCRIPTION
!  This subroutine is a wrapper for the computing core of the BFM
!
! !USES
   use mem, only: PELRIVER
   use constants,  only: SEC_PER_DAY

! !INPUT PARAMETERS:
   IMPLICIT NONE
   integer,intent(IN)        ::action
   integer,intent(IN)        ::n
   REALTYPE,intent(IN)       ::var(1:n)
   
!EOP
!-----------------------------------------------------------------------
!BOC
   if ( action >=1 ) then 
!    STDERR "do_bfm_river_loads action",action
     PELRIVER(1:n,1)=var(1:n) *SEC_PER_DAY
   else
     PELRIVER(1:n,1)=0.0D+00;
   endif
!  STDERR "do_bfm_river_loads",var(1:n)
!
   end subroutine do_bfm_river_loads
!EOC
!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Reset diagonal id a 3d array
!
! !INTERFACE:
   subroutine reset_diagonal(n,pp)
!
! !DESCRIPTION:
!    Reset of the diagonal
!
! !USES:
   IMPLICIT NONE
!
! !INPUT PARAMETERS:
   integer, intent(in)                    :: n
   REALTYPE,dimension(:,:,:),intent(inout) :: pp
!
! !REVISION HISTORY:
!  Original author(s): Piet Ruardij
!
! !LOCAL VARIABLES:
   integer                   :: i
!EOP
!-----------------------------------------------------------------------
!BOC
     do i=1,n
       pp(i,i,:) = _ZERO_
     end do

   return
   end subroutine reset_diagonal
!EOC
!-------------------------------------------------------------------------

!-------------------------------------------------------------------------
!BOP
!
! !IROUTINE: allocate_bfm
!
! !INTERFACE:
        subroutine allocate_memory_bfm(nlev)
!
! !INPUT PARAMETERS:
        implicit none
        integer,intent(IN)            ::nlev
!
! !LOCAL VARAIBELS:
   integer                   :: rc
!
! !DESCRIPTION:
!
! !BUGS:
!
! !SEE ALSO:
!
! !SYSTEM ROUTINES:
!
! !FILES USED:
!
! !REVISION HISTORY:
!
!  28-04-2006  Piet Ruardij Initial code.
!
!EOP
!-------------------------------------------------------------------------
!BOC

   if ( numc_diag > 0 ) then
     allocate(diag(1:numc_diag,0:nlev),stat=rc)
     if (rc /= 0) STOP 'allocate_memory_bfm: Error allocating (cc)'


     diag=_ZERO_                                                     !BFM
   endif


   if (bio_setup >= 2) then                                         !BFM
     ! allocate benthic state variables                             !BFM
     allocate(ccb(1:numbc,0:1),stat=rc)                             !BFM
     if (rc /= 0) STOP 'allocate_memory_bfm: Error allocating (ccb)'           !BFM
     allocate(ppb(1:numbc,1:numbc,0:1),stat=rc)                     !BFM
     if (rc /= 0) STOP 'allocate_memory_bfm: Error allocating (ppb)'           !BFM
     allocate(ddb(1:numbc,1:numbc,0:1),stat=rc)                     !BFM
     if (rc /= 0) STOP 'allocate_memory_bfm: Error allocating (ppb)'           !BFM

     ccb=_ZERO_                                                     !BFM
     ppb=_ZERO_                                                     !BFM
     ddb=_ZERO_                                                     !BFM

     ! allocate variable holding type and save attributes           !BFM
     allocate(benvar_type(1:numbc),stat=rc)                         !BFM
     if (rc /= 0) STOP 'allocate_memory_bfm: Error allocating (benvar_type)'   !BFM
     benvar_type = 0

     if ( numbc_diag > 0 ) then
       allocate(diagb(1:numbc_diag,0:1),stat=rc)
       if (rc /= 0) STOP 'allocate_memory_bfm: Error allocating (cc)'

       diagb=_ZERO_                                                     !BFM
     endif

   end if



 end subroutine allocate_memory_bfm
!EOC
!-------------------------------------------------------------------------

!-------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Test negative concentrations
!
! !INTERFACE:
       subroutine test_on_negative_states ( statenr,lldeep, h, nlev, after, error )
!
! !USES:
       use gotm_error_msg, only:set_warning_for_getm
       IMPLICIT NONE
!
! !INPUT PARAMETERS:
       integer,intent(in)                      :: statenr
       integer,intent(in)                      :: nlev
       logical,intent(in)                      :: lldeep
       REALTYPE,intent(in)                     :: h(0:nlev)
       character(len=*),intent(IN)             :: after
!
! !OUTPUT PARAMETERS:
       integer,intent(OUT)                     :: error
!          Array cldim is modified if ncecessry
!
! !LOCAL VARAIBELS:
        integer              ::k
        integer              ::i,n
        REALTYPE             ::r
        REALTYPE             ::sumbefore,sumafter
        character(len=160)   ::msg
        character(len=20)    ::onem

! !DESCRIPTION:
!   Routine to check for negative values.
!   Negative values are corrected with the aveage of neighbouring
!   grid points. A warning is given.
!
! !BUGS:
!
! !SEE ALSO:
!
! !SYSTEM ROUTINES:
!
! !FILES USED:
!
! !REVISION HISTORY:
!      created by P. Ruardij 21-06-2006
!
!
!EOP
!-------------------------------------------------------------------------
!BOC
       error=0
       ! in this way NaN are directly found!
       if (minval(c1dimz(1:nlev)) .ge. 0.00D+00) then           !BFM
          continue
       else
          if ( .not.lldeep ) then
              r=max(0.0D+00,sum(h(1:nlev)* c1dimz(1:nlev))/sum(h(1:nlev)))
              if ( r > 1.0D-10) then
                error=1
                write(msg,'(''statenr:'',I4,'' Negative value after call to '',A)') & 
                      statenr, after
                i=len_trim(msg)
                STDERR msg(1:i)
                STDERR "Averaging over the vertical value:",r
                call set_warning_for_getm()
             endif
             c1dimz(1:nlev)=r;
          else
            k=0                                                !BFM
            n=0
            sumbefore=sum(c1dimz(1:nlev)*h(1:nlev))
            do i = 1,nlev                                      !BFM
              if ( c1dimz(i).lt.0.0D+00) then                   !BFM
                  write(onem,'(I2,'':'',F10.3,''/'')') i,c1dimz(i) 
                  if (index(onem,'-')>0 )n=n+1
                  k=-i                                          !BFM
                  if ( i == 1 ) then
                     if ( c1dimz(i+1) > 0.0 )  then
                       c1dimz(i)=0.1* c1dimz(i+1)
                       k=i
                     else
                       c1dimz(i)=0.0
                       k=i
                     endif
                  elseif ( i == nlev ) then
                     if ( c1dimz(i-1) > 0.0 )  then
                       c1dimz(i)=0.1* c1dimz(i-1)
                       k=i
                     else
                       c1dimz(i)=0.0
                       k=i
                     endif
                  else if ( (c1dimz(i-1) > 0.0) .and. ( c1dimz(i+1)>0.0 ) ) then
                     k=i
                     c1dimz(i)=(c1dimz(i-1)+c1dimz(i+1)) * 0.1
                  else if ( c1dimz(i-1) >= 0.0 ) then
                       c1dimz(i)=0.1* c1dimz(i-1)
                       k=i
                  else if ( c1dimz(i+1) >= 0.0 ) then
                       c1dimz(i)=0.1* c1dimz(i+1)
                       k=i
                  endif
               endif
               if ( error.ge.0) error=k
            end do                                    !BFM
            sumafter=1.0D-80+sum(c1dimz(1:nlev)*h(1:nlev))
            r=max(0.0,sumbefore/sumafter)
            c1dimz=c1dimz*min(1.0,r)
            if ( n > 0 ) then
              call set_warning_for_getm()
              write(msg,'(''statenr='',I3,'' Negative values after '' &
                    ,A,'' n='',I2,'' shift='',F10.3,''%'')') &
                    statenr,after,n,100.0D+00*(1.0-r) 
              i=len_trim(msg)
              STDERR msg(1:i)
            endif
         endif
       endif

     end subroutine test_on_negative_states


!EOC
!-------------------------------------------------------------------------


!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Finish the bio calculations
!
! !INTERFACE:
   subroutine end_bio_bfm
!
! !DESCRIPTION:
!  Nothing done here --- supplied for completeness
!  with GOTM bio structure.
!
! !USES:
   IMPLICIT NONE
!
! !REVISION HISTORY:
!  Original author(s): Hans Burchard & Karsten Bolding
!
!EOP
!-----------------------------------------------------------------------
!BOC

   return
   end subroutine end_bio_bfm
!EOC

!-----------------------------------------------------------------------


   end module bio_bfm

!-----------------------------------------------------------------------
! Copyright by the GOTM-team and BFM-team under the GNU Public License
! www.gnu.org
!-----------------------------------------------------------------------
